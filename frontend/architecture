// /js
//  ├─ qst_type/                  # Logique métier et classes de base
//  │   ├─ Question.js         # Classe de base pour toutes les questions
//  │   ├─ TextQuestion.js     # Texte libre
//  │   ├─ SingleChoiceQuestion.js
//  │   ├─ MultipleChoiceQuestion.js
//  │   ├─ AutocompleteQuestion.js
//  │   ├─ SpinnerQuestion.js
//  │
//  ├─ rules/                 # Règles métier indépendantes
//  │   ├─ ExclusiveRule.js    # Pour les options “Aucun”, “Jamais”
//  │
//  │
//  ├─ store/                 # Gestion globale des réponses
//  │   ├─ AnswerStore.js
//  │
//  ├─ render/                    # Tout ce qui touche à l’UI
//  │   ├─ textRender.js
//  │  
//  │
//  ├─ utils/                  # Fonctions utilitaires
//  │   ├─ JSONLoader.js       # Charger différents templates
//  │
//  └─ main.js                

//  "rules": {
//     "onePerRow": true,  Impose une seule réponse par ligne
//     "requiredRows": ["bus", "train"],  Réponse obligatoire
//     "forbiddenCombinations": [ Interdit certaines valeurs pour certaines lignes
//       { "row": "bus", "value": "never" }
//     ]
//   }
// import Question from './Question.js';
// import QuestionContent from './QuestionContent.js';
// import SubQuestionRender from '../render/SubQuestionRender.js';
// import { showToast } from '../utils/toast.js';

// const subQuestionRender = new SubQuestionRender();

// export default class SingleChoiceQuestion extends Question {
//   constructor(step, store, renderer, allSteps = [], sources = {}) {
//     super(step, store, renderer);
//     this.allSteps = allSteps;
//     this.sources = sources;
//     this.selectedOption = null;
//     this.subQuestionInstance = null;
//     this.precisionHandler = null;
//   }
//   /**********************************Restauration depuis le store***************************************************** */
// init() {
//   this.existingAnswer = this.getAnswer();
//   console.log("réponse existante :this.existingAnswer",this.existingAnswer)
//   // Restaurer la sélection principale
//   if (this.existingAnswer?.value) {
//     this.selectedOption = this.step.options.find(
//       o => o.codeItem === this.existingAnswer.value.codeItem
//     );
//     // Restaurer la précision
//     if (this.existingAnswer.value.precision) {
//       this.selectedOption.precision = this.existingAnswer.value.precision;
//     }
//   } else {
//     this.selectedOption = null;
//   }
//   // Restaurer la sous-question
//   const subAnswerObj = this.existingAnswer?.subAnswer;
//   console.log("sub obj",subAnswerObj)
  
    
//   if (subAnswerObj) {
//     const subStepId = Object.keys(this.existingAnswer.subAnswer)[0];
//     console.log("sub id",subStepId)

//     // id de subQST
//     const subStep = this.allSteps.find(s => s.id === subStepId);
//     if (subStep) {
//       const tableData = subStep.table ? { [subStep.table]: this.sources[subStep.table] || [] } : {};
//       this.subQuestionInstance = new QuestionContent(subStep, this.allSteps, tableData, 'sub-question-template');
//       this.subQuestionInstance.initComponent();
//       console.log("subInstance ", this.subQuestionInstance)
//       const existingSubAnswer = subAnswerObj[subStepId] 
//       //|| this.store.get(subStep.id);
//       console.log("existingSubAnswer",existingSubAnswer)
//       if (existingSubAnswer) {
//         // Appel après initComponent
//         setTimeout(() => {
//           this.subQuestionInstance.component?.setAnswer(existingSubAnswer);
//         }, 0);
//       }
//       // Redéfinir setAnswer pour propager au parent
//       const subComp = this.subQuestionInstance.component;
//       if (subComp) {
//         const originalSetAnswer = subComp.setAnswer.bind(subComp);
//         subComp.setAnswer = (val) => {
//           originalSetAnswer(val);
//           this.setAnswer(this.buildAnswerObject());
//         };
//       }
//     }
//   } else {
//     this.subQuestionInstance = null;
//   }

//   this.step.component = this;
// }

// /**********************************Format stocké********************************************************************************* */
//   buildAnswerObject() {
//     if (!this.selectedOption) return null;

//     const valueObj = {
//       codeItem: this.selectedOption.codeItem,
//       label: this.selectedOption.label,
//       precision: this.selectedOption.precision || null
//     };

//     const answer = {
//       questionId: this.step.id,
//       type: 'single_choice',
//       value: valueObj
//     };

//     // Ajouter la sous-question si elle existe
//     if (this.subQuestionInstance) {
//       const subAnswerObj = this.subQuestionInstance.component?.buildAnswerObject?.();
//       if (subAnswerObj) {
//         answer.subAnswer = {
//           [this.subQuestionInstance.step.id]: subAnswerObj
//         };
//       }
//     }

//     return answer;
//   }
// /**************************************************************************Interaction utilisateur************************************** */
//   onChange(selected) {
    
//     this.selectedOption = this.step.options.find(o => o.codeItem === selected.value);
//     // Gestion précision
//     if (selected.precision) {
//       this.selectedOption.precision = selected.precision;
//     }
//     console.log('selectedOption complète:', this.selectedOption);

//     // Gestion sous-question
//     if (selected.requiresSubQst?.value) {
//       const subStep = this.allSteps.find(s => s.id === selected.requiresSubQst.subQst_id);
//       console.log('subStep', subStep)
//       if (subStep) {
//         const tableData = subStep.table ? 
//         { [subStep.table]: this.sources[subStep.table] || [] }
//          : {}; 
//         this.subQuestionInstance = new QuestionContent(subStep, this.allSteps, tableData, 'sub-question-template');
//         this.subQuestionInstance.initComponent();
//         // Pré-remplir si déjà existant
//         const existingSubAnswer = this.store.get(subStep.id);
//         if (existingSubAnswer) this.subQuestionInstance.component.setAnswer(existingSubAnswer);
//         // redéfinir setAnswer pour propager au parent
//         const subComp = this.subQuestionInstance.component;
//         if (subComp) {
//           const originalSetAnswer = subComp.setAnswer.bind(subComp);
//           subComp.setAnswer = (val) => {
//             originalSetAnswer(val);
//             this.setAnswer(this.buildAnswerObject());
//           };
//         }
//       }
//     } 
//     /*else {
//       this.subQuestionInstance = null;
//     }*/
//     // Sauvegarder la réponse principale avec buildAnswerObject
//     this.setAnswer(this.buildAnswerObject());
//   }

//   /**********************************************Validation complète********************* */
//   isValid() {
//     console.log("this.selectedOption", this.selectedOption)
//     // Vérification réponse principale
//     if (!this.selectedOption?.codeItem) {
//       showToast('Veuillez sélectionner une option');
//       return false;
//     }
//     // Vérification précision 
//     if (this.selectedOption.requiresPrecision && (!this.selectedOption.precision || this.selectedOption.precision.trim() === '')) {
//       showToast('Veuillez préciser votre réponse');
//       return false;
//     }
//     // Validation récursive sous-question 
//     if (this.subQuestionInstance) {
//       const subValid = this.subQuestionInstance.isValid?.();
//       if (!subValid) return false;
//     }

//     return true;
//   }
//   /**********************************************************Affichage principal*********************************** */
//   render() {
//     this.init();
//     const container = this.renderer.renderSingleChoice(
//       this.step,
//       this.existingAnswer,

//       (selected) => {
//         this.onChange(selected);
//         this.renderSubQuestion(container);
//       }
//     );

//     this.renderSubQuestion(container);
//     return container;
//   }
//   renderSubQuestion(container) {
//     if (!this.subQuestionInstance) return;

//     const oldSub = container.querySelector('.sub-question-container');
//     if (oldSub) oldSub.remove();

//     const subContainer = subQuestionRender.renderSubQuestion(this.subQuestionInstance);
//     container.appendChild(subContainer);
//   }


// }
